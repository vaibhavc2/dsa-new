[
    {
        "created": "2023-01-05T13:23:26.246Z",
        "name": "built-in int typedefs",
        "tags": [
            "typedefs int long short char"
        ],
        "content": "    /* int8_t // char\n    int16_t // short int\n    int32_t // int\n    int64_t // long\n    uint8_t // unsigned char\n    uint16_t // unsigned short int\n    uint32_t // unsigned int\n    uint64_t // unsigned long */",
        "contentType": "cpp"
    },
    {
        "created": "2023-01-05T13:24:49.847Z",
        "name": "main function snippet",
        "tags": [
            "cpp main function"
        ],
        "content": "//*/*-------- MAIN FUNCTION --------*/*//\nint main() {\n    fastIO();\n    fileIO();\n\n    // !! xxxxxxxx !! START FROM HERE !! xxxxxxxx !!\n    //*/*--------- implementation code ---------*/*//\n\n\n\n    return 0;\n}",
        "contentType": "cpp"
    },
    {
        "created": "2023-01-05T13:26:01.544Z",
        "name": "fileIO snippet",
        "tags": [
            "file input output function"
        ],
        "content": "// Lambda expression (or function) for INPUT-OUTPUT to file\nauto fileIO = [](){\n    #ifdef LOCAL_PROJECT // or, ONLINE_JUDGE\n    (void)!freopen(\"INPUT.txt\", \"r\", stdin);\n    (void)!freopen(\"OUTPUT.txt\", \"w\", stdout);\n    #endif\n};",
        "contentType": "cpp"
    },
    {
        "created": "2023-01-05T13:26:54.019Z",
        "name": "fastIO snippet",
        "tags": [
            "fastIO : sync cin cout with scanf and printf"
        ],
        "content": "#define fastIO() ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)",
        "contentType": "cpp"
    },
    {
        "created": "2023-01-05T13:28:30.499Z",
        "name": "endl macro snippet",
        "tags": [
            "endl flushes output everytime, hence is very slow in performance. we need to flush only once to the screen."
        ],
        "content": "#define endl \"\\n\"",
        "contentType": "cpp"
    },
    {
        "created": "2023-01-05T13:29:30.935Z",
        "name": "my MACROS",
        "tags": [
            "useful macros for cp"
        ],
        "content": "//* MACROS\n// Predefined constants\n#define MOD 1000000007\n#define MOD1 998244353\n#define eps 1e-12\n#define INF 2e18\n#define PI 3.141592653589793238462\n#define imax numeric_limits<int>::max()\n#define lmax numeric_limits<int64_t>::max()\n#define llmax numeric_limits<ll>::max()\n#define imin numeric_limits<int>::min()\n#define lmin numeric_limits<int64_t>::min()\n#define llmin numeric_limits<ll>::min()\n// Other Macros\n#define endl \"\\n\"\n// #define ln \"\\n\"     //use in interactive problems\n#define set_bits __builtin_popcount\n#define set_bitsl __builtin_popcountl\n#define set_bitsll __builtin_popcountll\n#define getParity __builtin_parity // 1 - odd no. of setbits, 0 - even no. of setbits\n#define all(x) (x).begin(), (x).end()\n#define fastIO() ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)\n\n//*/*----------------------------------*/*//\n",
        "contentType": "cpp"
    },
    {
        "created": "2023-01-05T13:31:07.144Z",
        "name": "GCC optimizations",
        "tags": [
            "optimize gcc with some flags to improve performance, but disable in debugging mode"
        ],
        "content": "//* OPTIMIZATIONS\n#ifndef DEBUG\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif",
        "contentType": "cpp"
    },
    {
        "created": "2023-02-07T18:05:56.521Z",
        "name": "BigInt C++ class",
        "tags": [
            "BigInt (can store unlimited number of digits)"
        ],
        "content": "//*/*-------------- BigInt Implementation --------------*/*//\n// ======================================================= //\n\n/*\n    Definition for the BigInt class.\n*/\n\n#ifndef CP_INCLUDES\n#include <iostream>\n#include <tuple>\n#include <random>\n#include <climits>\n#include <string>\n#include <cmath>\n#endif\n\n#ifndef BIG_INT_HPP\n#define BIG_INT_HPP\n\nclass BigInt {\n    std::string value;\n    char sign;\n\n    public:\n        // Constructors:\n        BigInt();\n        BigInt(const BigInt&);\n        BigInt(const long long&);\n        BigInt(const std::string&);\n\n        // Assignment operators:\n        BigInt& operator=(const BigInt&);\n        BigInt& operator=(const long long&);\n        BigInt& operator=(const std::string&);\n\n        // Unary arithmetic operators:\n        BigInt operator+() const;   // unary +\n        BigInt operator-() const;   // unary -\n\n        // Binary arithmetic operators:\n        BigInt operator+(const BigInt&) const;\n        BigInt operator-(const BigInt&) const;\n        BigInt operator*(const BigInt&) const;\n        BigInt operator/(const BigInt&) const;\n        BigInt operator%(const BigInt&) const;\n        BigInt operator+(const long long&) const;\n        BigInt operator-(const long long&) const;\n        BigInt operator*(const long long&) const;\n        BigInt operator/(const long long&) const;\n        BigInt operator%(const long long&) const;\n        BigInt operator+(const std::string&) const;\n        BigInt operator-(const std::string&) const;\n        BigInt operator*(const std::string&) const;\n        BigInt operator/(const std::string&) const;\n        BigInt operator%(const std::string&) const;\n\n        // Arithmetic-assignment operators:\n        BigInt& operator+=(const BigInt&);\n        BigInt& operator-=(const BigInt&);\n        BigInt& operator*=(const BigInt&);\n        BigInt& operator/=(const BigInt&);\n        BigInt& operator%=(const BigInt&);\n        BigInt& operator+=(const long long&);\n        BigInt& operator-=(const long long&);\n        BigInt& operator*=(const long long&);\n        BigInt& operator/=(const long long&);\n        BigInt& operator%=(const long long&);\n        BigInt& operator+=(const std::string&);\n        BigInt& operator-=(const std::string&);\n        BigInt& operator*=(const std::string&);\n        BigInt& operator/=(const std::string&);\n        BigInt& operator%=(const std::string&);\n\n        // Increment and decrement operators:\n        BigInt& operator++();       // pre-increment\n        BigInt& operator--();       // pre-decrement\n        BigInt operator++(int);     // post-increment\n        BigInt operator--(int);     // post-decrement\n\n        // Relational operators:\n        bool operator<(const BigInt&) const;\n        bool operator>(const BigInt&) const;\n        bool operator<=(const BigInt&) const;\n        bool operator>=(const BigInt&) const;\n        bool operator==(const BigInt&) const;\n        bool operator!=(const BigInt&) const;\n        bool operator<(const long long&) const;\n        bool operator>(const long long&) const;\n        bool operator<=(const long long&) const;\n        bool operator>=(const long long&) const;\n        bool operator==(const long long&) const;\n        bool operator!=(const long long&) const;\n        bool operator<(const std::string&) const;\n        bool operator>(const std::string&) const;\n        bool operator<=(const std::string&) const;\n        bool operator>=(const std::string&) const;\n        bool operator==(const std::string&) const;\n        bool operator!=(const std::string&) const;\n\n        // I/O stream operators:\n        friend std::istream& operator>>(std::istream&, BigInt&);\n        friend std::ostream& operator<<(std::ostream&, const BigInt&);\n\n        // Conversion functions:\n        std::string to_string() const;\n        int to_int() const;\n        long to_long() const;\n        long long to_long_long() const;\n\n        // Random number generating functions:\n        friend BigInt big_random(size_t);\n};\n\n#endif  // BIG_INT_HPP\n\n\n/*\n    ===========================================================================\n    Utility functions\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_UTILITY_FUNCTIONS_HPP\n#define BIG_INT_UTILITY_FUNCTIONS_HPP\n\n\n/*\n    is_valid_number\n    ---------------\n    Checks whether the given string is a valid integer.\n*/\n\nbool is_valid_number(const std::string& num) {\n    for (char digit : num)\n        if (digit < '0' or digit > '9')\n            return false;\n\n    return true;\n}\n\n\n/*\n    strip_leading_zeroes\n    --------------------\n    Strip the leading zeroes from a number represented as a string.\n*/\n\nvoid strip_leading_zeroes(std::string& num) {\n    size_t i;\n    for (i = 0; i < num.size(); i++)\n        if (num[i] != '0')\n            break;\n\n    if (i == num.size())\n        num = \"0\";\n    else\n        num = num.substr(i);\n}\n\n\n/*\n    add_leading_zeroes\n    ------------------\n    Adds a given number of leading zeroes to a string-represented integer `num`.\n*/\n\nvoid add_leading_zeroes(std::string& num, size_t num_zeroes) {\n    num = std::string(num_zeroes, '0') + num;\n}\n\n\n/*\n    add_trailing_zeroes\n    -------------------\n    Adds a given number of trailing zeroes to a string-represented integer `num`.\n*/\n\nvoid add_trailing_zeroes(std::string& num, size_t num_zeroes) {\n    num += std::string(num_zeroes, '0');\n}\n\n\n/*\n    get_larger_and_smaller\n    ----------------------\n    Identifies the given string-represented integers as `larger` and `smaller`,\n    padding the smaller number with leading zeroes to make it equal in length to\n    the larger number.\n*/\n\nstd::tuple<std::string, std::string> get_larger_and_smaller(const std::string& num1,\n        const std::string& num2) {\n    std::string larger, smaller;\n    if (num1.size() > num2.size() or\n        (num1.size() == num2.size() and num1 > num2)) {\n        larger = num1;\n        smaller = num2;\n    }\n    else {\n        larger = num2;\n        smaller = num1;\n    }\n\n    // pad the smaller number with zeroes\n    add_leading_zeroes(smaller, larger.size() - smaller.size());\n\n    return std::make_tuple(larger, smaller);\n}\n\n\n/*\n    is_power_of_10\n    ----------------------\n    Checks whether a string-represented integer is a power of 10.\n*/\n\nbool is_power_of_10(const std::string& num){\n    if (num[0] != '1')\n        return false;\n    for (size_t i = 1; i < num.size(); i++)\n        if (num[i] != '0')\n            return false;\n\n    return true;    // first digit is 1 and the following digits are all 0\n}\n\n#endif  // BIG_INT_UTILITY_FUNCTIONS_HPP\n\n\n/*\n    ===========================================================================\n    Random number generating functions for BigInt\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_RANDOM_FUNCTIONS_HPP\n#define BIG_INT_RANDOM_FUNCTIONS_HPP\n\n\n// when the number of digits are not specified, a random value is used for it\n// which is kept below the following:\nconst size_t MAX_RANDOM_LENGTH = 1000;\n\n\n/*\n    big_random (num_digits)\n    -----------------------\n    Returns a random BigInt with a specific number of digits.\n*/\n\nBigInt big_random(size_t num_digits = 0) {\n    std::random_device rand_generator;      // true random number generator\n\n    if (num_digits == 0)    // the number of digits were not specified\n        // use a random number for it:\n        num_digits = 1 + rand_generator() % MAX_RANDOM_LENGTH;\n\n    BigInt big_rand;\n    big_rand.value = \"\";    // clear value to append digits\n\n    // ensure that the first digit is non-zero\n    big_rand.value += std::to_string(1 + rand_generator() % 9);\n\n    while (big_rand.value.size() < num_digits)\n        big_rand.value += std::to_string(rand_generator());\n    if (big_rand.value.size() != num_digits)\n        big_rand.value.erase(num_digits);   // erase extra digits\n\n    return big_rand;\n}\n\n\n#endif  // BIG_INT_RANDOM_FUNCTIONS_HPP\n\n\n/*\n    ===========================================================================\n    Constructors\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_CONSTRUCTORS_HPP\n#define BIG_INT_CONSTRUCTORS_HPP\n\n\n\n/*\n    Default constructor\n    -------------------\n*/\n\nBigInt::BigInt() {\n    value = \"0\";\n    sign = '+';\n}\n\n\n/*\n    Copy constructor\n    ----------------\n*/\n\nBigInt::BigInt(const BigInt& num) {\n    value = num.value;\n    sign = num.sign;\n}\n\n\n/*\n    Integer to BigInt\n    -----------------\n*/\n\nBigInt::BigInt(const long long& num) {\n    value = std::to_string(std::abs(num));\n    if (num < 0)\n        sign = '-';\n    else\n        sign = '+';\n}\n\n\n/*\n    String to BigInt\n    ----------------\n*/\n\nBigInt::BigInt(const std::string& num) {\n    if (num[0] == '+' or num[0] == '-') {     // check for sign\n        std::string magnitude = num.substr(1);\n        if (is_valid_number(magnitude)) {\n            value = magnitude;\n            sign = num[0];\n        }\n        else {\n            throw std::invalid_argument(\"Expected an integer, got \\'\" + num + \"\\'\");\n        }\n    }\n    else {      // if no sign is specified\n        if (is_valid_number(num)) {\n            value = num;\n            sign = '+';    // positive by default\n        }\n        else {\n            throw std::invalid_argument(\"Expected an integer, got \\'\" + num + \"\\'\");\n        }\n    }\n    strip_leading_zeroes(value);\n}\n\n#endif  // BIG_INT_CONSTRUCTORS_HPP\n\n\n/*\n    ===========================================================================\n    Conversion functions for BigInt\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_CONVERSION_FUNCTIONS_HPP\n#define BIG_INT_CONVERSION_FUNCTIONS_HPP\n\n\n/*\n    to_string\n    ---------\n    Converts a BigInt to a string.\n*/\n\nstd::string BigInt::to_string() const {\n    // prefix with sign if negative\n    return this->sign == '-' ? \"-\" + this->value : this->value;\n}\n\n\n/*\n    to_int\n    ------\n    Converts a BigInt to an int.\n    NOTE: If the BigInt is out of range of an int, stoi() will throw an\n    out_of_range exception.\n*/\n\nint BigInt::to_int() const {\n    return std::stoi(this->to_string());\n}\n\n\n/*\n    to_long\n    -------\n    Converts a BigInt to a long int.\n    NOTE: If the BigInt is out of range of a long int, stol() will throw an\n    out_of_range exception.\n*/\n\nlong BigInt::to_long() const {\n    return std::stol(this->to_string());\n}\n\n\n/*\n    to_long_long\n    ------------\n    Converts a BigInt to a long long int.\n    NOTE: If the BigInt is out of range of a long long int, stoll() will throw\n    an out_of_range exception.\n*/\n\nlong long BigInt::to_long_long() const {\n    return std::stoll(this->to_string());\n}\n\n#endif  // BIG_INT_CONVERSION_FUNCTIONS_HPP\n\n\n/*\n    ===========================================================================\n    Assignment operators\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_ASSIGNMENT_OPERATORS_HPP\n#define BIG_INT_ASSIGNMENT_OPERATORS_HPP\n\n\n\n/*\n    BigInt = BigInt\n    ---------------\n*/\n\nBigInt& BigInt::operator=(const BigInt& num) {\n    value = num.value;\n    sign = num.sign;\n\n    return *this;\n}\n\n\n/*\n    BigInt = Integer\n    ----------------\n*/\n\nBigInt& BigInt::operator=(const long long& num) {\n    BigInt temp(num);\n    value = temp.value;\n    sign = temp.sign;\n\n    return *this;\n}\n\n\n/*\n    BigInt = String\n    ---------------\n*/\n\nBigInt& BigInt::operator=(const std::string& num) {\n    BigInt temp(num);\n    value = temp.value;\n    sign = temp.sign;\n\n    return *this;\n}\n\n#endif  // BIG_INT_ASSIGNMENT_OPERATORS_HPP\n\n\n/*\n    ===========================================================================\n    Unary arithmetic operators\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_UNARY_ARITHMETIC_OPERATORS_HPP\n#define BIG_INT_UNARY_ARITHMETIC_OPERATORS_HPP\n\n\n\n/*\n    +BigInt\n    -------\n    Returns the value of a BigInt.\n    NOTE: This function does not return the absolute value. To get the absolute\n    value of a BigInt, use the `abs` function.\n*/\n\nBigInt BigInt::operator+() const {\n    return *this;\n}\n\n\n/*\n    -BigInt\n    -------\n    Returns the negative of a BigInt.\n*/\n\nBigInt BigInt::operator-() const {\n    BigInt temp;\n\n    temp.value = value;\n    if (value != \"0\") {\n        if (sign == '+')\n            temp.sign = '-';\n        else\n            temp.sign = '+';\n    }\n\n    return temp;\n}\n\n#endif  // BIG_INT_UNARY_ARITHMETIC_OPERATORS_HPP\n\n\n/*\n    ===========================================================================\n    Relational operators\n    ===========================================================================\n    All operators depend on the '<' and/or '==' operator(s).\n*/\n\n#ifndef BIG_INT_RELATIONAL_OPERATORS_HPP\n#define BIG_INT_RELATIONAL_OPERATORS_HPP\n\n\n\n/*\n    BigInt == BigInt\n    ----------------\n*/\n\nbool BigInt::operator==(const BigInt& num) const {\n    return (sign == num.sign) and (value == num.value);\n}\n\n\n/*\n    BigInt != BigInt\n    ----------------\n*/\n\nbool BigInt::operator!=(const BigInt& num) const {\n    return !(*this == num);\n}\n\n\n/*\n    BigInt < BigInt\n    ---------------\n*/\n\nbool BigInt::operator<(const BigInt& num) const {\n    if (sign == num.sign) {\n        if (sign == '+') {\n            if (value.length() == num.value.length())\n                return value < num.value;\n            else\n                return value.length() < num.value.length();\n        }\n        else\n            return -(*this) > -num;\n    }\n    else\n        return sign == '-';\n}\n\n\n/*\n    BigInt > BigInt\n    ---------------\n*/\n\nbool BigInt::operator>(const BigInt& num) const {\n    return !((*this < num) or (*this == num));\n}\n\n\n/*\n    BigInt <= BigInt\n    ----------------\n*/\n\nbool BigInt::operator<=(const BigInt& num) const {\n    return (*this < num) or (*this == num);\n}\n\n\n/*\n    BigInt >= BigInt\n    ----------------\n*/\n\nbool BigInt::operator>=(const BigInt& num) const {\n    return !(*this < num);\n}\n\n\n/*\n    BigInt == Integer\n    -----------------\n*/\n\nbool BigInt::operator==(const long long& num) const {\n    return *this == BigInt(num);\n}\n\n\n/*\n    Integer == BigInt\n    -----------------\n*/\n\nbool operator==(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) == rhs;\n}\n\n\n/*\n    BigInt != Integer\n    -----------------\n*/\n\nbool BigInt::operator!=(const long long& num) const {\n    return !(*this == BigInt(num));\n}\n\n\n/*\n    Integer != BigInt\n    -----------------\n*/\n\nbool operator!=(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) != rhs;\n}\n\n\n/*\n    BigInt < Integer\n    ----------------\n*/\n\nbool BigInt::operator<(const long long& num) const {\n    return *this < BigInt(num);\n}\n\n\n/*\n    Integer < BigInt\n    ----------------\n*/\n\nbool operator<(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) < rhs;\n}\n\n\n/*\n    BigInt > Integer\n    ----------------\n*/\n\nbool BigInt::operator>(const long long& num) const {\n    return *this > BigInt(num);\n}\n\n\n/*\n    Integer > BigInt\n    ----------------\n*/\n\nbool operator>(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) > rhs;\n}\n\n\n/*\n    BigInt <= Integer\n    -----------------\n*/\n\nbool BigInt::operator<=(const long long& num) const {\n    return !(*this > BigInt(num));\n}\n\n\n/*\n    Integer <= BigInt\n    -----------------\n*/\n\nbool operator<=(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) <= rhs;\n}\n\n\n/*\n    BigInt >= Integer\n    -----------------\n*/\n\nbool BigInt::operator>=(const long long& num) const {\n    return !(*this < BigInt(num));\n}\n\n\n/*\n    Integer >= BigInt\n    -----------------\n*/\n\nbool operator>=(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) >= rhs;\n}\n\n\n/*\n    BigInt == String\n    ----------------\n*/\n\nbool BigInt::operator==(const std::string& num) const {\n    return *this == BigInt(num);\n}\n\n\n/*\n    String == BigInt\n    ----------------\n*/\n\nbool operator==(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) == rhs;\n}\n\n\n/*\n    BigInt != String\n    ----------------\n*/\n\nbool BigInt::operator!=(const std::string& num) const {\n    return !(*this == BigInt(num));\n}\n\n\n/*\n    String != BigInt\n    ----------------\n*/\n\nbool operator!=(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) != rhs;\n}\n\n\n/*\n    BigInt < String\n    ---------------\n*/\n\nbool BigInt::operator<(const std::string& num) const {\n    return *this < BigInt(num);\n}\n\n\n/*\n    String < BigInt\n    ---------------\n*/\n\nbool operator<(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) < rhs;\n}\n\n\n/*\n    BigInt > String\n    ---------------\n*/\n\nbool BigInt::operator>(const std::string& num) const {\n    return *this > BigInt(num);\n}\n\n\n/*\n    String > BigInt\n    ---------------\n*/\n\nbool operator>(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) > rhs;\n}\n\n\n/*\n    BigInt <= String\n    ----------------\n*/\n\nbool BigInt::operator<=(const std::string& num) const {\n    return !(*this > BigInt(num));\n}\n\n\n/*\n    String <= BigInt\n    ----------------\n*/\n\nbool operator<=(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) <= rhs;\n}\n\n\n/*\n    BigInt >= String\n    ----------------\n*/\n\nbool BigInt::operator>=(const std::string& num) const {\n    return !(*this < BigInt(num));\n}\n\n\n/*\n    String >= BigInt\n    ----------------\n*/\n\nbool operator>=(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) >= rhs;\n}\n\n#endif  // BIG_INT_RELATIONAL_OPERATORS_HPP\n\n\n/*\n    ===========================================================================\n    Math functions for BigInt\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_MATH_FUNCTIONS_HPP\n#define BIG_INT_MATH_FUNCTIONS_HPP\n\n\n\n/*\n    abs\n    ---\n    Returns the absolute value of a BigInt.\n*/\n\nBigInt abs(const BigInt& num) {\n    return num < 0 ? -num : num;\n}\n\n\n/*\n    big_pow10\n    ---------\n    Returns a BigInt equal to 10^exp.\n    NOTE: exponent should be a non-negative integer.\n*/\n\nBigInt big_pow10(size_t exp) {\n    return BigInt(\"1\" + std::string(exp, '0'));\n}\n\n\n/*\n    pow (BigInt)\n    ------------\n    Returns a BigInt equal to base^exp.\n*/\n\nBigInt pow(const BigInt& base, int exp) {\n    if (exp < 0) {\n        if (base == 0)\n            throw std::logic_error(\"Cannot divide by zero\");\n        return abs(base) == 1 ? base : 0;\n    }\n    if (exp == 0) {\n        if (base == 0)\n            throw std::logic_error(\"Zero cannot be raised to zero\");\n        return 1;\n    }\n\n    BigInt result = base, result_odd = 1;\n    while (exp > 1) {\n        if (exp % 2)\n            result_odd *= result;\n        result *= result;\n        exp /= 2;\n    }\n\n    return result * result_odd;\n}\n\n\n/*\n    pow (Integer)\n    -------------\n    Returns a BigInt equal to base^exp.\n*/\n\nBigInt pow(const long long& base, int exp) {\n    return pow(BigInt(base), exp);\n}\n\n\n/*\n    pow (String)\n    ------------\n    Returns a BigInt equal to base^exp.\n*/\n\nBigInt pow(const std::string& base, int exp) {\n    return pow(BigInt(base), exp);\n\n}\n\n\n/*\n    sqrt\n    ----\n    Returns the positive integer square root of a BigInt using Newton's method.\n    NOTE: the input must be non-negative.\n*/\n\nBigInt sqrt(const BigInt& num) {\n    if (num < 0)\n        throw std::invalid_argument(\"Cannot compute square root of a negative integer\");\n\n    // Optimisations for small inputs:\n    if (num == 0)\n        return 0;\n    else if (num < 4)\n        return 1;\n    else if (num < 9)\n        return 2;\n    else if (num < 16)\n        return 3;\n\n    BigInt sqrt_prev = -1;\n    // The value for `sqrt_current` is chosen close to that of the actual\n    // square root.\n    // Since a number's square root has at least one less than half as many\n    // digits as the number,\n    //     sqrt_current = 10^(half_the_digits_in_num - 1)\n    BigInt sqrt_current = big_pow10(num.to_string().size() / 2 - 1);\n\n    while (abs(sqrt_current - sqrt_prev) > 1) {\n        sqrt_prev = sqrt_current;\n        sqrt_current = (num / sqrt_prev + sqrt_prev) / 2;\n    }\n\n    return sqrt_current;\n}\n\n\n/*\n    gcd(BigInt, BigInt)\n    -------------------\n    Returns the greatest common divisor (GCD, a.k.a. HCF) of two BigInts using\n    Euclid's algorithm.\n*/\n\nBigInt gcd(const BigInt &num1, const BigInt &num2){\n    BigInt abs_num1 = abs(num1);\n    BigInt abs_num2 = abs(num2);\n\n    // base cases:\n    if (abs_num2 == 0)\n        return abs_num1;    // gcd(a, 0) = |a|\n    if (abs_num1 == 0)\n        return abs_num2;    // gcd(0, a) = |a|\n\n    BigInt remainder = abs_num2;\n    while (remainder != 0) {\n        remainder = abs_num1 % abs_num2;\n        abs_num1 = abs_num2;    // previous remainder\n        abs_num2 = remainder;   // current remainder\n    }\n\n    return abs_num1;\n}\n\n\n/*\n    gcd(BigInt, Integer)\n    --------------------\n*/\n\nBigInt gcd(const BigInt& num1, const long long& num2){\n    return gcd(num1, BigInt(num2));\n}\n\n\n/*\n    gcd(BigInt, String)\n    -------------------\n*/\n\nBigInt gcd(const BigInt& num1, const std::string& num2){\n    return gcd(num1, BigInt(num2));\n}\n\n\n/*\n    gcd(Integer, BigInt)\n    --------------------\n*/\n\nBigInt gcd(const long long& num1, const BigInt& num2){\n    return gcd(BigInt(num1), num2);\n}\n\n\n/*\n    gcd(String, BigInt)\n    -------------------\n*/\n\nBigInt gcd(const std::string& num1, const BigInt& num2){\n    return gcd(BigInt(num1), num2);\n}\n\n\n/*\n    lcm(BigInt, BigInt)\n    -------------------\n    Returns the least common multiple (LCM) of two BigInts.\n*/\n\nBigInt lcm(const BigInt& num1, const BigInt& num2) {\n    if (num1 == 0 or num2 == 0)\n        return 0;\n\n    return abs(num1 * num2) / gcd(num1, num2);\n}\n\n\n/*\n    lcm(BigInt, Integer)\n    --------------------\n*/\n\nBigInt lcm(const BigInt& num1, const long long& num2){\n    return lcm(num1, BigInt(num2));\n}\n\n\n/*\n    lcm(BigInt, String)\n    -------------------\n*/\n\nBigInt lcm(const BigInt& num1, const std::string& num2){\n    return lcm(num1, BigInt(num2));\n}\n\n\n/*\n    lcm(Integer, BigInt)\n    --------------------\n*/\n\nBigInt lcm(const long long& num1, const BigInt& num2){\n    return lcm(BigInt(num1), num2);\n}\n\n\n/*\n    lcm(String, BigInt)\n    -------------------\n*/\n\nBigInt lcm(const std::string& num1, const BigInt& num2){\n    return lcm(BigInt(num1), num2);\n}\n\n\n#endif  // BIG_INT_MATH_FUNCTIONS_HPP\n\n\n/*\n    ===========================================================================\n    Binary arithmetic operators\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_BINARY_ARITHMETIC_OPERATORS_HPP\n#define BIG_INT_BINARY_ARITHMETIC_OPERATORS_HPP\n\n\nconst long long FLOOR_SQRT_LLONG_MAX = 3037000499;\n\n\n/*\n    BigInt + BigInt\n    ---------------\n    The operand on the RHS of the addition is `num`.\n*/\n\nBigInt BigInt::operator+(const BigInt& num) const {\n    // if the operands are of opposite signs, perform subtraction\n    if (this->sign == '+' and num.sign == '-') {\n        BigInt rhs = num;\n        rhs.sign = '+';\n        return *this - rhs;\n    }\n    else if (this->sign == '-' and num.sign == '+') {\n        BigInt lhs = *this;\n        lhs.sign = '+';\n        return -(lhs - num);\n    }\n\n    // identify the numbers as `larger` and `smaller`\n    std::string larger, smaller;\n    std::tie(larger, smaller) = get_larger_and_smaller(this->value, num.value);\n\n    BigInt result;      // the resultant sum\n    result.value = \"\";  // the value is cleared as the digits will be appended\n    short carry = 0, sum;\n    // add the two values\n    for (long i = larger.size() - 1; i >= 0; i--) {\n        sum = larger[i] - '0' + smaller[i] - '0' + carry;\n        result.value = std::to_string(sum % 10) + result.value;\n        carry = sum / (short) 10;\n    }\n    if (carry)\n        result.value = std::to_string(carry) + result.value;\n\n    // if the operands are negative, the result is negative\n    if (this->sign == '-' and result.value != \"0\")\n        result.sign = '-';\n\n    return result;\n}\n\n\n/*\n    BigInt - BigInt\n    ---------------\n    The operand on the RHS of the subtraction is `num`.\n*/\n\nBigInt BigInt::operator-(const BigInt& num) const {\n    // if the operands are of opposite signs, perform addition\n    if (this->sign == '+' and num.sign == '-') {\n        BigInt rhs = num;\n        rhs.sign = '+';\n        return *this + rhs;\n    }\n    else if (this->sign == '-' and num.sign == '+') {\n        BigInt lhs = *this;\n        lhs.sign = '+';\n        return -(lhs + num);\n    }\n\n    BigInt result;      // the resultant difference\n    // identify the numbers as `larger` and `smaller`\n    std::string larger, smaller;\n    if (abs(*this) > abs(num)) {\n        larger = this->value;\n        smaller = num.value;\n\n        if (this->sign == '-')      // -larger - -smaller = -result\n            result.sign = '-';\n    }\n    else {\n        larger = num.value;\n        smaller = this->value;\n\n        if (num.sign == '+')        // smaller - larger = -result\n            result.sign = '-';\n    }\n    // pad the smaller number with zeroes\n    add_leading_zeroes(smaller, larger.size() - smaller.size());\n\n    result.value = \"\";  // the value is cleared as the digits will be appended\n    short difference;\n    long i, j;\n    // subtract the two values\n    for (i = larger.size() - 1; i >= 0; i--) {\n        difference = larger[i] - smaller[i];\n        if (difference < 0) {\n            for (j = i - 1; j >= 0; j--) {\n                if (larger[j] != '0') {\n                    larger[j]--;    // borrow from the j-th digit\n                    break;\n                }\n            }\n            j++;\n            while (j != i) {\n                larger[j] = '9';    // add the borrow and take away 1\n                j++;\n            }\n            difference += 10;   // add the borrow\n        }\n        result.value = std::to_string(difference) + result.value;\n    }\n    strip_leading_zeroes(result.value);\n\n    // if the result is 0, set its sign as +\n    if (result.value == \"0\")\n        result.sign = '+';\n\n    return result;\n}\n\n\n/*\n    BigInt * BigInt\n    ---------------\n    Computes the product of two BigInts using Karatsuba's algorithm.\n    The operand on the RHS of the product is `num`.\n*/\n\nBigInt BigInt::operator*(const BigInt& num) const {\n    if (*this == 0 or num == 0)\n        return BigInt(0);\n    if (*this == 1)\n        return num;\n    if (num == 1)\n     return *this;\n\n    BigInt product;\n    if (abs(*this) <= FLOOR_SQRT_LLONG_MAX and abs(num) <= FLOOR_SQRT_LLONG_MAX)\n        product = std::stoll(this->value) * std::stoll(num.value);\n    else if (is_power_of_10(this->value)){ // if LHS is a power of 10 do optimised operation \n        product.value = num.value;\n        product.value.append(this->value.begin() + 1, this->value.end());\n    }\n    else if (is_power_of_10(num.value)){ // if RHS is a power of 10 do optimised operation \n        product.value = this->value;\n        product.value.append(num.value.begin() + 1, num.value.end());\n    }\n    else {\n        // identify the numbers as `larger` and `smaller`\n        std::string larger, smaller;\n        std::tie(larger, smaller) = get_larger_and_smaller(this->value, num.value);\n\n        size_t half_length = larger.size() / 2;\n        auto half_length_ceil = (size_t) ceil(larger.size() / 2.0);\n\n        BigInt num1_high, num1_low;\n        num1_high = larger.substr(0, half_length);\n        num1_low = larger.substr(half_length);\n\n        BigInt num2_high, num2_low;\n        num2_high = smaller.substr(0, half_length);\n        num2_low = smaller.substr(half_length);\n\n        strip_leading_zeroes(num1_high.value);\n        strip_leading_zeroes(num1_low.value);\n        strip_leading_zeroes(num2_high.value);\n        strip_leading_zeroes(num2_low.value);\n\n        BigInt prod_high, prod_mid, prod_low;\n        prod_high = num1_high * num2_high;\n        prod_low = num1_low * num2_low;\n        prod_mid = (num1_high + num1_low) * (num2_high + num2_low)\n                   - prod_high - prod_low;\n\n        add_trailing_zeroes(prod_high.value, 2 * half_length_ceil);\n        add_trailing_zeroes(prod_mid.value, half_length_ceil);\n\n        strip_leading_zeroes(prod_high.value);\n        strip_leading_zeroes(prod_mid.value);\n        strip_leading_zeroes(prod_low.value);\n\n        product = prod_high + prod_mid + prod_low;\n    }\n    strip_leading_zeroes(product.value);\n\n    if (this->sign == num.sign)\n        product.sign = '+';\n    else\n        product.sign = '-';\n\n    return product;\n}\n\n\n/*\n    divide\n    ------\n    Helper function that returns the quotient and remainder on dividing the\n    dividend by the divisor, when the divisor is 1 to 10 times the dividend.\n*/\n\nstd::tuple<BigInt, BigInt> divide(const BigInt& dividend, const BigInt& divisor) {\n    BigInt quotient, remainder, temp;\n\n    temp = divisor;\n    quotient = 1;\n    while (temp < dividend) {\n        quotient++;\n        temp += divisor;\n    }\n    if (temp > dividend) {\n        quotient--;\n        remainder = dividend - (temp - divisor);\n    }\n\n    return std::make_tuple(quotient, remainder);\n}\n\n\n/*\n    BigInt / BigInt\n    ---------------\n    Computes the quotient of two BigInts using the long-division method.\n    The operand on the RHS of the division (the divisor) is `num`.\n*/\n\nBigInt BigInt::operator/(const BigInt& num) const {\n    BigInt abs_dividend = abs(*this);\n    BigInt abs_divisor = abs(num);\n\n    if (num == 0)\n        throw std::logic_error(\"Attempted division by zero\");\n    if (abs_dividend < abs_divisor)\n        return BigInt(0);\n    if (num == 1)\n        return *this;\n    if (num == -1)\n        return -(*this);\n\n    BigInt quotient;\n    if (abs_dividend <= LLONG_MAX and abs_divisor <= LLONG_MAX)\n        quotient = std::stoll(abs_dividend.value) / std::stoll(abs_divisor.value);\n    else if (abs_dividend == abs_divisor)\n        quotient = 1;\n    else if (is_power_of_10(abs_divisor.value)) { // if divisor is a power of 10 do optimised calculation\n        size_t digits_in_quotient = abs_dividend.value.size() - abs_divisor.value.size() + 1;\n        quotient.value = abs_dividend.value.substr(0, digits_in_quotient);\n    }\n    else {\n        quotient.value = \"\";    // the value is cleared as digits will be appended\n        BigInt chunk, chunk_quotient, chunk_remainder;\n        size_t chunk_index = 0;\n        chunk_remainder.value = abs_dividend.value.substr(chunk_index, abs_divisor.value.size() - 1);\n        chunk_index = abs_divisor.value.size() - 1;\n        while (chunk_index < abs_dividend.value.size()) {\n            chunk.value = chunk_remainder.value.append(1, abs_dividend.value[chunk_index]);\n            chunk_index++;\n            while (chunk < abs_divisor) {\n                quotient.value += \"0\";\n                if (chunk_index < abs_dividend.value.size()) {\n                    chunk.value.append(1, abs_dividend.value[chunk_index]);\n                    chunk_index++;\n                }\n                else\n                    break;\n            }\n            if (chunk == abs_divisor) {\n                quotient.value += \"1\";\n                chunk_remainder = 0;\n            }\n            else if (chunk > abs_divisor) {\n                strip_leading_zeroes(chunk.value);\n                std::tie(chunk_quotient, chunk_remainder) = divide(chunk, abs_divisor);\n                quotient.value += chunk_quotient.value;\n            }\n        }\n    }\n    strip_leading_zeroes(quotient.value);\n\n    if (this->sign == num.sign)\n        quotient.sign = '+';\n    else\n        quotient.sign = '-';\n\n    return quotient;\n}\n\n\n/*\n    BigInt % BigInt\n    ---------------\n    Computes the modulo (remainder on division) of two BigInts.\n    The operand on the RHS of the modulo (the divisor) is `num`.\n*/\n\nBigInt BigInt::operator%(const BigInt& num) const {\n    BigInt abs_dividend = abs(*this);\n    BigInt abs_divisor = abs(num);\n\n    if (abs_divisor == 0)\n        throw std::logic_error(\"Attempted division by zero\");\n    if (abs_divisor == 1 or abs_divisor == abs_dividend)\n        return BigInt(0);\n\n    BigInt remainder;\n    if (abs_dividend <= LLONG_MAX and abs_divisor <= LLONG_MAX)\n        remainder = std::stoll(abs_dividend.value) % std::stoll(abs_divisor.value);\n    else if (abs_dividend < abs_divisor)\n        remainder = abs_dividend;\n    else if (is_power_of_10(num.value)){ // if num is a power of 10 use optimised calculation\n        size_t no_of_zeroes = num.value.size() - 1;\n        remainder.value = abs_dividend.value.substr(abs_dividend.value.size() - no_of_zeroes);\n    } \n    else {\n        BigInt quotient = abs_dividend / abs_divisor;\n        remainder = abs_dividend - quotient * abs_divisor;\n    }\n    strip_leading_zeroes(remainder.value);\n\n    // remainder has the same sign as that of the dividend\n    remainder.sign = this->sign;\n    if (remainder.value == \"0\")     // except if its zero\n        remainder.sign = '+';\n\n    return remainder;\n}\n\n\n/*\n    BigInt + Integer\n    ----------------\n*/\n\nBigInt BigInt::operator+(const long long& num) const {\n    return *this + BigInt(num);\n}\n\n\n/*\n    Integer + BigInt\n    ----------------\n*/\n\nBigInt operator+(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) + rhs;\n}\n\n\n/*\n    BigInt - Integer\n    ----------------\n*/\n\nBigInt BigInt::operator-(const long long& num) const {\n    return *this - BigInt(num);\n}\n\n\n/*\n    Integer - BigInt\n    ----------------\n*/\n\nBigInt operator-(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) - rhs;\n}\n\n\n/*\n    BigInt * Integer\n    ----------------\n*/\n\nBigInt BigInt::operator*(const long long& num) const {\n    return *this * BigInt(num);\n}\n\n\n/*\n    Integer * BigInt\n    ----------------\n*/\n\nBigInt operator*(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) * rhs;\n}\n\n\n/*\n    BigInt / Integer\n    ----------------\n*/\n\nBigInt BigInt::operator/(const long long& num) const {\n    return *this / BigInt(num);\n}\n\n\n/*\n    Integer / BigInt\n    ----------------\n*/\n\nBigInt operator/(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) / rhs;\n}\n\n\n/*\n    BigInt % Integer\n    ----------------\n*/\n\nBigInt BigInt::operator%(const long long& num) const {\n    return *this % BigInt(num);\n}\n\n\n/*\n    Integer % BigInt\n    ----------------\n*/\n\nBigInt operator%(const long long& lhs, const BigInt& rhs) {\n    return BigInt(lhs) % rhs;\n}\n\n\n/*\n    BigInt + String\n    ---------------\n*/\n\nBigInt BigInt::operator+(const std::string& num) const {\n    return *this + BigInt(num);\n}\n\n\n/*\n    String + BigInt\n    ---------------\n*/\n\nBigInt operator+(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) + rhs;\n}\n\n\n/*\n    BigInt - String\n    ---------------\n*/\n\nBigInt BigInt::operator-(const std::string& num) const {\n    return *this - BigInt(num);\n}\n\n\n/*\n    String - BigInt\n    ---------------\n*/\n\nBigInt operator-(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) - rhs;\n}\n\n\n/*\n    BigInt * String\n    ---------------\n*/\n\nBigInt BigInt::operator*(const std::string& num) const {\n    return *this * BigInt(num);\n}\n\n\n/*\n    String * BigInt\n    ---------------\n*/\n\nBigInt operator*(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) * rhs;\n}\n\n\n/*\n    BigInt / String\n    ---------------\n*/\n\nBigInt BigInt::operator/(const std::string& num) const {\n    return *this / BigInt(num);\n}\n\n\n/*\n    String / BigInt\n    ---------------\n*/\n\nBigInt operator/(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) / rhs;\n}\n\n\n/*\n    BigInt % String\n    ---------------\n*/\n\nBigInt BigInt::operator%(const std::string& num) const {\n    return *this % BigInt(num);\n}\n\n\n/*\n    String % BigInt\n    ---------------\n*/\n\nBigInt operator%(const std::string& lhs, const BigInt& rhs) {\n    return BigInt(lhs) % rhs;\n}\n\n#endif  // BIG_INT_BINARY_ARITHMETIC_OPERATORS_HPP\n\n\n/*\n    ===========================================================================\n    Arithmetic-assignment operators\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_ARITHMETIC_ASSIGNMENT_OPERATORS_HPP\n#define BIG_INT_ARITHMETIC_ASSIGNMENT_OPERATORS_HPP\n\n\n\n/*\n    BigInt += BigInt\n    ----------------\n*/\n\nBigInt& BigInt::operator+=(const BigInt& num) {\n    *this = *this + num;\n\n    return *this;\n}\n\n\n/*\n    BigInt -= BigInt\n    ----------------\n*/\n\nBigInt& BigInt::operator-=(const BigInt& num) {\n    *this = *this - num;\n\n    return *this;\n}\n\n\n/*\n    BigInt *= BigInt\n    ----------------\n*/\n\nBigInt& BigInt::operator*=(const BigInt& num) {\n    *this = *this * num;\n\n    return *this;\n}\n\n\n/*\n    BigInt /= BigInt\n    ----------------\n*/\n\nBigInt& BigInt::operator/=(const BigInt& num) {\n    *this = *this / num;\n\n    return *this;\n}\n\n\n/*\n    BigInt %= BigInt\n    ----------------\n*/\n\nBigInt& BigInt::operator%=(const BigInt& num) {\n    *this = *this % num;\n\n    return *this;\n}\n\n\n/*\n    BigInt += Integer\n    -----------------\n*/\n\nBigInt& BigInt::operator+=(const long long& num) {\n    *this = *this + BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt -= Integer\n    -----------------\n*/\n\nBigInt& BigInt::operator-=(const long long& num) {\n    *this = *this - BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt *= Integer\n    -----------------\n*/\n\nBigInt& BigInt::operator*=(const long long& num) {\n    *this = *this * BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt /= Integer\n    -----------------\n*/\n\nBigInt& BigInt::operator/=(const long long& num) {\n    *this = *this / BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt %= Integer\n    -----------------\n*/\n\nBigInt& BigInt::operator%=(const long long& num) {\n    *this = *this % BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt += String\n    ----------------\n*/\n\nBigInt& BigInt::operator+=(const std::string& num) {\n    *this = *this + BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt -= String\n    ----------------\n*/\n\nBigInt& BigInt::operator-=(const std::string& num) {\n    *this = *this - BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt *= String\n    ----------------\n*/\n\nBigInt& BigInt::operator*=(const std::string& num) {\n    *this = *this * BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt /= String\n    ----------------\n*/\n\nBigInt& BigInt::operator/=(const std::string& num) {\n    *this = *this / BigInt(num);\n\n    return *this;\n}\n\n\n/*\n    BigInt %= String\n    ----------------\n*/\n\nBigInt& BigInt::operator%=(const std::string& num) {\n    *this = *this % BigInt(num);\n\n    return *this;\n}\n\n#endif  // BIG_INT_ARITHMETIC_ASSIGNMENT_OPERATORS_HPP\n\n\n/*\n    ===========================================================================\n    Increment and decrement operators\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_INCREMENT_DECREMENT_OPERATORS_HPP\n#define BIG_INT_INCREMENT_DECREMENT_OPERATORS_HPP\n\n\n\n/*\n    Pre-increment\n    -------------\n    ++BigInt\n*/\n\nBigInt& BigInt::operator++() {\n    *this += 1;\n\n    return *this;\n}\n\n\n/*\n    Pre-decrement\n    -------------\n    --BigInt\n*/\n\nBigInt& BigInt::operator--() {\n    *this -= 1;\n\n    return *this;\n}\n\n\n/*\n    Post-increment\n    --------------\n    BigInt++\n*/\n\nBigInt BigInt::operator++(int) {\n    BigInt temp = *this;\n    *this += 1;\n\n    return temp;\n}\n\n\n/*\n    Post-decrement\n    --------------\n    BigInt--\n*/\n\nBigInt BigInt::operator--(int) {\n    BigInt temp = *this;\n    *this -= 1;\n\n    return temp;\n}\n\n#endif  // BIG_INT_INCREMENT_DECREMENT_OPERATORS_HPP\n\n/*\n    OTHER IMPORTANT FUNCTIONS IMPLEMENTED\n*/\n\nBigInt max(BigInt a, BigInt b) {\n    if (a > b) return a;\n    return b;\n}\n\nBigInt min(BigInt a, BigInt b) {\n    if (a < b) return a;\n    return b;\n}\n\nBigInt log(int n, BigInt a) { // log_n(a)\n    BigInt ans = 0;\n    while (a > 1) {\n        ans++;\n        a /= n;\n    }\n    return ans;\n}\n\n\n/*\n    ===========================================================================\n    I/O stream operators\n    ===========================================================================\n*/\n\n#ifndef BIG_INT_IO_STREAM_OPERATORS_HPP\n#define BIG_INT_IO_STREAM_OPERATORS_HPP\n\n\n\n/*\n    BigInt from input stream\n    ------------------------\n*/\n\nstd::istream& operator>>(std::istream& in, BigInt& num) {\n    std::string input;\n    in >> input;\n    num = BigInt(input);  // remove sign from value and set sign, if exists\n\n    return in;\n}\n\n\n/*\n    BigInt to output stream\n    -----------------------\n*/\n\nstd::ostream& operator<<(std::ostream& out, const BigInt& num) {\n    if (num.sign == '-')\n        out << num.sign;\n    out << num.value;\n\n    return out;\n}\n\n#endif  // BIG_INT_IO_STREAM_OPERATORS_HPP\n\n// ======================================================= //\n//*/*------------------- BigInt OVER -------------------*/*//",
        "contentType": "cpp"
    },
    {
        "created": "2023-02-22T19:44:05.879Z",
        "name": "python-template",
        "tags": [
            "cp python"
        ],
        "content": "#!/usr/bin/env python3\n\n# /---------------------------------------/ #\n# *************** CP TEMPLATE ************* #\nfrom __future__ import division, print_function\n\nimport os\nfrom os import path\nimport sys\nfrom io import BytesIO, IOBase\n\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\nif (path.exists('INPUT.txt') and path.exists('OUTPUT.txt')):\n\tsys.stdin = open('INPUT.txt', 'r')\n\tsys.stdout = open('OUTPUT.txt', 'w')\n\n\n# START OF FASTIO\n#----------------------------------------#\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# END OF FASTIO\n#----------------------------------------#\n\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ #\n# ************** START HERE *************** #\n\ndef solve():\n    pass\n\ndef main():\n    t = 1;\n    t = int(input());\n    while t:\n        t = t - 1;\n        solve();\n\nif __name__ == \"__main__\":\n    main()\n",
        "contentType": "python"
    },
    {
        "created": "2023-03-11T07:27:31.978Z",
        "name": "Normal template boilerplate",
        "tags": [
            "boilerplate"
        ],
        "content": "#include <bits/stdc++.h>\nusing namespace std;\n\nauto fileIO = [](){\n    #ifdef LOCAL_PROJECT\n    (void)!freopen(\"INPUT.txt\", \"r\", stdin);\n    (void)!freopen(\"OUTPUT.txt\", \"w\", stdout);\n    #endif\n};\n\n#define fastIO() ios_base::sync_with_stdio(false); cin.tie(nullptr)\n#define endl '\\n'\n\ninline void solve() {\n}\n\nint32_t main() {\n    fileIO();\n    fastIO();\n    int t = 1;\n    // cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
        "contentType": "cpp"
    },
    {
        "created": "2024-11-14T17:05:10.882Z",
        "name": "leetcode",
        "tags": [
            "cpp leetcode template latest"
        ],
        "content": "// ---------- CP SETUP ---------- //\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define cerr cerr << \"ERROR :: \"\n\n#define db_precision numeric_limits<double>::digits10 + 1\n#define DOUBLE()                  \\\n    cout.precision(db_precision); \\\n    cout << fixed\n\n// ************* IO Implementations *************\n\ntemplate <typename T>\ninline void _print(const T &x) {\n    cout << x;\n}\n\ntemplate <typename T, typename V>\ninline void _print(const pair<T, V> &p) {\n    cout << \"{ \";\n    _print(p.first);\n    cout << \", \";\n    _print(p.second);\n    cout << \" }\";\n}\n\ntemplate <typename T>\ninline void _print(const vector<T> &v) {\n    cout << \"{ \";\n    for (size_t i = 0; i < v.size(); ++i) {\n        _print(v[i]);\n        if (i + 1 != v.size()) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T>\ninline void _print(const deque<T> &d) {\n    cout << \"{ \";\n    for (size_t i = 0; i < d.size(); ++i) {\n        _print(d[i]);\n        if (i + 1 != d.size()) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T>\ninline void _print(const list<T> &l) {\n    cout << \"{ \";\n    for (auto it = l.begin(); it != l.end(); ++it) {\n        _print(*it);\n        if (next(it) != l.end()) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T>\ninline void _print(const set<T> &s) {\n    cout << \"{ \";\n    for (auto it = s.begin(); it != s.end(); ++it) {\n        _print(*it);\n        if (next(it) != s.end()) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T>\ninline void _print(const unordered_set<T> &s) {\n    cout << \"{ \";\n    bool first = true;\n    for (const auto &x : s) {\n        if (!first) cout << \", \";\n        _print(x);\n        first = false;\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T>\ninline void _print(const multiset<T> &ms) {\n    cout << \"{ \";\n    for (auto it = ms.begin(); it != ms.end(); ++it) {\n        _print(*it);\n        if (next(it) != ms.end()) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T, typename V>\ninline void _print(const map<T, V> &m) {\n    cout << \"{ \";\n    for (auto it = m.begin(); it != m.end(); ++it) {\n        _print(*it);\n        if (next(it) != m.end()) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T, typename V>\ninline void _print(const unordered_map<T, V> &m) {\n    cout << \"{ \";\n    bool first = true;\n    for (const auto p : m) {\n        if (!first) cout << \", \";\n        _print(p);\n        first = false;\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T>\ninline void _print(stack<T> s) {\n    vector<T> temp;\n    while (!s.empty()) {\n        temp.push_back(s.top());\n        s.pop();\n    }\n    reverse(temp.begin(), temp.end());\n    _print(temp);\n}\n\ntemplate <typename T>\ninline void _print(queue<T> q) {\n    vector<T> temp;\n    while (!q.empty()) {\n        temp.push_back(q.front());\n        q.pop();\n    }\n    _print(temp);\n}\n\ntemplate <typename T>\ninline void _print(priority_queue<T> pq) {\n    vector<T> temp;\n    while (!pq.empty()) {\n        temp.push_back(pq.top());\n        pq.pop();\n    }\n    sort(temp.rbegin(), temp.rend());\n    _print(temp);\n}\n\ntemplate <typename T, size_t N>\ninline void _print(const array<T, N> &arr) {\n    cout << \"{ \";\n    for (size_t i = 0; i < N; ++i) {\n        _print(arr[i]);\n        if (i + 1 != N) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename T, size_t N>\ninline void _print(const T (&arr)[N]) {\n    cout << \"{ \";\n    for (size_t i = 0; i < N; ++i) {\n        _print(arr[i]);\n        if (i + 1 != N) cout << \", \";\n    }\n    cout << \" }\";\n}\n\ntemplate <typename... Args>\ninline void _print(const tuple<Args...> &t) {\n    cout << \"( \";\n    apply([](const auto &...args) { ((cout << args << \", \"), ...); }, t);\n    cout.seekp(-2, ios_base::cur);\n    cout << \" )\";\n}\n\ntemplate <typename T>\ninline void print(const T x) {\n    _print(x);\n    cout << endl;\n}\n\ntemplate <typename T, typename... Args>\ninline void print(const T x, const Args... args) {\n    _print(x);\n    cout << endl;\n    print(args...);\n}\n\nenum InputMethod {\n    Standard,\n    Line\n};\n\ntemplate <typename T>\ninline void _input(T &x, InputMethod method = Standard) {\n    if constexpr (is_same<T, string>::value) {\n        if (method == Line) {\n            cin.ignore();  // ignores a new line ('\\n')\n            cin.ignore();  // ignores a new line ('\\n')\n            getline(cin, x);\n        } else {\n            cin >> x;\n        }\n    } else {\n        cin >> x;\n    }\n}\n\ntemplate <typename T, size_t N>\ninline void _input(array<T, N> &arr, InputMethod method = Standard) {\n    for (auto &x : arr) {\n        _input(x, method);\n    }\n}\n\ntemplate <typename T>\ninline void _input(vector<T> &v, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    v.resize(n);\n    for (auto &x : v) {\n        _input(x, method);\n    }\n}\n\ntemplate <typename T>\ninline void _input(set<T> &s, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        T x;\n        _input(x, method);\n        s.insert(x);\n    }\n}\n\ntemplate <typename T>\ninline void _input(unordered_set<T> &s, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        T x;\n        _input(x, method);\n        s.insert(x);\n    }\n}\n\ntemplate <typename T>\ninline void _input(multiset<T> &s, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        T x;\n        _input(x, method);\n        s.insert(x);\n    }\n}\n\ntemplate <typename T, typename V>\ninline void _input(map<T, V> &m, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        pair<T, V> p;\n        _input(p, method);\n        m.insert(p);\n    }\n}\n\ntemplate <typename T, typename V>\ninline void _input(unordered_map<T, V> &m, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        pair<T, V> p;\n        _input(p, method);\n        m.insert(p);\n    }\n}\n\ntemplate <typename T>\ninline void _input(list<T> &l, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    l.clear();\n    for (int i = 0; i < n; ++i) {\n        T x;\n        _input(x, method);\n        l.push_back(x);\n    }\n}\n\ntemplate <typename T>\ninline void _input(queue<T> &q, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    while (!q.empty()) q.pop();\n    for (int i = 0; i < n; ++i) {\n        T x;\n        _input(x, method);\n        q.push(x);\n    }\n}\n\ntemplate <typename T>\ninline void _input(deque<T> &d, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    d.resize(n);\n    for (auto &x : d) {\n        _input(x, method);\n    }\n}\n\ntemplate <typename T>\ninline void _input(stack<T> &s, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    vector<T> temp(n);\n    for (int i = 0; i < n; ++i) {\n        _input(temp[i], method);\n    }\n    reverse(temp.begin(), temp.end());\n    while (!s.empty()) s.pop();\n    for (auto &x : temp) {\n        s.push(x);\n    }\n}\n\ntemplate <typename T>\ninline void _input(priority_queue<T> &pq, InputMethod method = Standard) {\n    int n;\n    cin >> n;\n    while (!pq.empty()) pq.pop();\n    for (int i = 0; i < n; ++i) {\n        T x;\n        _input(x, method);\n        pq.push(x);\n    }\n}\n\ntemplate <typename... Args>\ninline void _input(tuple<Args...> &t, InputMethod method = Standard) {\n    apply([method](auto &&...args) { ((_input(args, method)), ...); }, t);\n}\n\ntemplate <typename T>\ninline void _input(T *arr, size_t n, InputMethod method = Standard) {\n    for (size_t i = 0; i < n; ++i) {\n        _input(arr[i], method);\n    }\n}\n\ntemplate <typename T, size_t N>\ninline void _input(T (&arr)[N]) {\n    for (size_t i = 0; i < N; ++i) {\n        cin >> arr[i];\n    }\n}\n\ntemplate <typename... Args>\ninline void input(InputMethod method, Args &...args) {\n    (_input(args, method), ...);\n}\n\n// !! xxxxxxxx !! START FROM HERE !! xxxxxxxx !!\n\n//*/*-------------- SOLUTION --------------*/*//\n\n// @lc code=start\n\n// ------------- OPTIMIZATIONS -------------\n\n#ifndef LOCAL_PROJECT\n#pragma GCC optimize(\"O3,unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,lzcnt,abm,bmi,bmi2,mmx,avx,avx2,fma\")\n\nauto fastIO = []() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    return 0;\n}();\n#endif\n\n// ------------- CODE -------------\n\n// const int N = 1e5+1;\n// int a[N];\n// const int MOD = 1e9+7;\n// const int _MOD = 998244353;\n// const double EPS = 1e-9;\n// const long long INF = 2e18;\n// const int mxN = 2e5+5;\n// const double PI = 4 * atan(1);\nusing ll = long long;\nnamespace rng = std::ranges;\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n\nclass Solution {\n   public:\n    int func(int &n) {\n        return n;\n    }\n};\n\n// @lc code=end\n\n//*/*-------------- SOLUTIONS --------------*/*//\n\n//*/*-------------- SOLUTIONS --------------*/*//\n\nvoid solve() {\n    int x;\n    string s;\n    vector<int> v;\n    vector<vector<int>> vv;\n\n    input(Standard, v, x);\n    // input(Line, s);\n\n    Solution sol;\n    auto ans = sol.func(x);\n    print(ans);\n}\n\nint32_t main() {\n    DOUBLE();\n    int t = 1;\n    cin >> t;\n\n#ifdef DEBUG\n    while (t--) solve();\n#else\n    const int timeout_seconds = 5;\n    for (int test_case = 1; test_case <= t; ++test_case) {\n        auto future = async(launch::async, solve);  // Run solve() in a separate thread\n\n        if (future.wait_for(chrono::seconds(timeout_seconds)) == future_status::timeout) {\n            cerr << \"Time Limit Exceeded at 'Test case: \" << test_case << \"'\\n\";\n            exit(0);  // exit the program\n        }\n    }\n#endif\n\n    return 0;\n}\n\n// ------------- END -------------",
        "contentType": "cpp"
    },
    {
        "created": "2024-11-14T18:05:51.553Z",
        "name": "string utils",
        "tags": [
            "string"
        ],
        "content": "inline void convert_str_to_lowercase(string &s) {\n    transform(s.begin(), s.end(), s.begin(),\n              [](unsigned char c) { return tolower(c); });\n}\n\ninline void trim(string &str) {\n    size_t first = str.find_first_not_of(' ');\n    if (string::npos == first) {\n        return;\n    }\n    size_t last = str.find_last_not_of(' ');\n    str = str.substr(first, (last - first + 1));\n}",
        "contentType": "cpp"
    }
]